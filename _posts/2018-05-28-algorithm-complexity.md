---
layout: post
title: "算法复杂度" 
---
# 1、算法的定义

算法一般是对计算机来说的，具体指定义良好的指令序列，它将输入数据转换成输出结果。

# 2、数量级标记

设$f$和$g$是从$\mathbb{N}$到$\mathbb{N}$的两个函数。

1）如果存在常数$c$使得$\frac{f(n)}{g(n)} \leq c$对充分大的$n$恒成立，则称$f(n)=O(g(n))$，也称$f(n)=\omega(g(n))$；

2）如果$f(n)=O(g(n))$且$g(n)=O(f(n))$，则称$f(n)=\Theta (g(n))$；

3）如果对任意$\epsilon > 0$均有$\frac{f(n)}{g(n)} \leq \epsilon$对充分大的$n$恒成立，则称$f(n)=o(g(n))$，也称$f(n)=\Omega(g(n))$。

对于输入规模为$n$的的算法，其计算复杂度由易到难排名如下：

1）$O(1)$，常数时间；

2）$O(\log n)$，对数时间；

3）$O((\log n)^c)$，多对数时间；

4）$O(n)$，线性时间；

5）$O(n\log n)$，线性对数时间；

6）$O(n^c)$，多项式时间；

7）$O(c^n)$，指数时间；

8）$O(n!)$，阶乘时间。

# 3、图灵机

图灵机是一种抽象的机器，它定义了一种计算模型。按照CT论点（Church-Turing thesis），任何可被物理实现的计算装置均可以被图灵机模拟，也就是说任何其他计算模型上的可计算问题的集合不会比图灵机上可计算问题的集合更大。而在计算效率方面，强CT论点更是断言，任何可物理实现的计算模型均可以被图灵机以多项式倍的代价来模拟，也就是说任何其他模型的$t$个计算步骤可以用图灵机的$t^c$个步骤来模拟，其中$c$是不依赖于模型输入规模的常数。然而，强CT论点是存在争议的，因为目前出现的量子计算机模型似乎不能被图灵机高效模拟。但另一方面，目前也不清楚量子计算机能否被物理实现。下面将给出图灵机的具体定义。

## 3.1 确定型图灵机

### 3.1.1 基本定义

一个确定型图灵机构造出一台假想的机器，由四个部分组成：一条无限长的存储带（tape）、一个读写头（head）、一个状态寄存器（register）以及一套控制规则（table）。存储带分成许多小方格，每小格可存储一个位数（0或1），也可以是空白的。机器的运作是逐步进行的，每一步可以由以下三个步骤构成：

1）机器获取寄存器存储的状态以及当前读写头对准方格的字符，根据控制规则决定接下来的操作；

2）机器对方格进行操作，可以保持原有的字符也可以写入另一个字符；

3）机器操作读写头向右或向左移动一个方格。

由上可知，在给定初始状态和输入后，机器的行为自始至终是由控制规则（table）来决定的。当到达某些状态时，机器结束运行，计算结束。

可以通过以下六元组来形式化描述一个典型的确定型图灵机：

$$M=(Q,\Sigma,\Gamma,q_0,q_{halt},\delta)$$

其中，

$Q$：状态集，包含$M$的寄存器种可能出现的所有状态。

$\Sigma$：输入字母集，包含$M$的输入信息中允许出现的所有字符，一般只包括0和1。

$\Gamma$：带字母表，包含$M$的存储带上允许出现的所有符号。其中，$\Sigma \subset \Gamma$。同时，$\Gamma$中还包含一个特定的“空白符”，记为$\square$。

$q_0 \in Q$：初始状态。

$q_{halt} \in Q$：终止状态。

$$\delta:(Q \backslash \{q_{halt}\}) \times \Gamma \rightarrow Q \times \Gamma \times \{L,R\}$$：转移函数，定义系统内部格局是如何变化的，其中$L$、$R$分别表示读写头是向左移还是向右移。

初始的时候将输入字符串从第0号格子开始从左至右依次填写到存储带上的格子中，其他格子保持空白。读写头指向第0号格子，且寄存器存储的状态为$q_0$。$M$开始运行后，按照转移函数$\delta$所描述的控制规则进行计算。若在某时刻，读写头所指的是第0号格子，但根据转移函数下一步将继续向左移，这时它停在原地不动，即读写头始终不移出纸带的左边界。若在某时刻根据转移函数进入了终止状态则$M$立刻停机并将存储带上的内容输出。需要注意的是，$M$可能进入循环状态，永远不停机。

令$$f:\{0,1\}^* \rightarrow \{0,1\}^*$$表示一个任意定义在二进制字串上的函数，如果将$f$的输入$x \in \\{0,1\\}^*$作为$M$的输入字符串，当$M$处于终止状态时，将$f(x)$写在其存储带上，我们就称$M$计算$f$。设$T:\mathbb{N} \rightarrow \mathbb{N}$，如果$M$在任意输入$x$上计算$f(x)$时最多只需要$T(\|x\|)$个步骤，则称$M$在$O(T(n))$时间内计算$f$（$n$代表输入的规模）。计算过程也可以表示为$M(x) = f(x)$。

上面图灵机的定义有以下几个事实：

1）该模型对定义中几乎所有微调均是鲁棒的。改变图灵机的带字母表并不会改变其计算能力，我们显然可以用带字母表为$\\{0,1\\}$的图灵机模拟带字母表为任意有限集合$\Gamma$的图灵机；如果我们允许图灵机的存储带两端都可以无限伸展，这并不能增加图灵机的计算能力，因为我们显然可以用只有存储带一端能无限伸展的图灵机来模拟这种存储带两端都可以无限伸展的图灵机；如果我们允许图灵机的读写头在某一步保持原地不动，那也不会增加其计算能力，因为我们可以用向左移一次再向右移一次来代替在原地不动；加入接受状态和拒绝状态并不会改变其计算能力，它们都属于终止状态，我们可以用终止时输出1或0来表示接受或拒绝；该模型最基本的形式能够模拟其最复杂的形式执行计算，最多运行时间会慢多项式倍。

2）采用一定的规范编码，每个图灵机（即算法）都可以表示为一个位串（bit string）。因此，一个图灵机可能是另一个图灵机的输入——这使得软件和硬件之间的界限非常柔性。我们可以用$M_{\alpha}$来代表可以用位串$\alpha$来表示的图灵机。

3）对于任何一个给定位串表示的图灵机$M_{\alpha}$，存在通用图灵机$U$可以模拟执行其计算操作，且模拟过程是高效的。例如，给定位串对$(\alpha,x)$，通用图灵机$U$可以模拟$M_{\alpha}$在输入$x$上的操作过程，如果$M_{\alpha}$的运行时间为$T(\|x\|)$，则$U$的运行时间为$O(T(\|x\|)\log T(\|x\|))$ （该问题的证明涉及到将任意多带图灵机转换成单带图灵机，可以通过对多带图灵机上每条带上的信息进行特殊编码，使得符号移动具有较低的平摊代价，从而实现高效转换）。

4）简单利用前面两个事实可以证明，存在不能被任何图灵机计算的函数。可以定义函数$$UC: \{0,1\}^* \rightarrow \{0,1\}$$，对于任意$$\alpha \in \{0,1\}^*$$，如果$M_{\alpha}(\alpha) = 1$，则$UC(\alpha) = 0$；否则（若$M_{\alpha}(\alpha)$输出其他值或进入无限循环）$UC(\alpha) = 1$。可以验证，$UC$是不可被任何图灵机计算的，否则使用表示该图灵机的位串作为输入会产生自相矛盾。

### 3.1.2 格局与可判定语言

图灵机当前的格局可以用符号$uqv$表示，其中$q$表示当前状态，$u$和$v$是带字母表$\Gamma$上的两个字符串，$uv$代表当前带上的存储内容，读写头当前指向的位置是$v$的第一个符号，$v$的最后一个符号后面的方格里全是空白符。根据控制规则，可以从当前格局产生下一格局。

我们定义对所有输入都停机（即肯定会进入终止格局，不会循环）且输出为1或0的确定型图灵机为确定型判定器（determinate decider）。

确定型判定器$M$对应一个可确定型判定的语言$L$，满足对任意字符串$x \in L, x' \notin L$有$M(x)=1, M(x')=0$。

### 3.1.3 Problem与Instance之间的关系

一般来说一个problem包括两个部分：

1）对所有输入参数的一般性描述；

2）对输出必须满足性质的描述。

而当一个problem给定其所有输入参数的具体值后就变成一个instance。因此对于可判定语言来说，语言可以对应为一个problem，而语言中的一个字符串可以对应一个instance，每个instance都属于该problem。


## 3.2 非确定型图灵机

对于非确定型图灵机，其转移函数可以表示为：

$$\delta:(Q \backslash \{q_{halt}\}) \times \Gamma \rightarrow 2^{Q \times \Gamma \times \{L,R\}}$$

$M$将从其结果中任意选择一个元素当作控制规则进行操作，然后进行下一步计算。

非确定型图灵机$M$在输入字符串$x$上的计算过程可以表示为一棵树，不同的分支对应着该步计算的不同可能性。某些分支可能会进入循环，但只要有一个分支可以进入终止格局，我们就说$M$在输入$x$上可计算。需要注意的是，我们规定$M$必须是没有自相矛盾的，即不能有一个分支接受而另一个分支拒绝，或者两个分支同时接受但输出结果不一样，这样存在自相矛盾的非确定型图灵机是不合法的。

设$T:\mathbb{N} \rightarrow \mathbb{N}$，同样令$$f:\{0,1\}^* \rightarrow \{0,1\}^*$$表示一个任意定义在二进制字串上的函数，如果对于任意的$x \in \\{0,1\\}^*$输入到非确定型图灵机$M$时，均存在一个非确定型选择序列，也即存在一个分支，使得$M$在$T(\|x\|)$个步骤内可以达到终止格局且将$f(x)$写在其存储带上，我们就称$M$在$O(T(n))$时间内计算$f$（$n$代表输入的规模）。计算过程也可以表示为$M(x) = f(x)$。

类似地，对于非确定型图灵机，可以定义非确定型判定器与可非确定型判定的语言。

对于非确定型图灵机$M$，可构造一个确定型图灵机$M'$如下：

1）令$k=1$；

2）以深度优先规则模拟$M$的每个分支的计算，但每个分支最多只计算$k$步，如果某个分支在$k$步内可以停机，则$M'$也停机，并将该分支的计算结果作为输出；

3）若没有停机，令$k$增加1，跳转到上一步继续执行。

显然$M'$和$M$是等价的。

**定理：** 每一个非确定型图灵机都等价于一个确定型图灵机。

**定理：** 如果语言$L$被非确定型图灵机在多项式时间$P(n)$内计算，则语言$L$一定能被一个确定型图灵机以时间复杂度为$O(c^{P(n)})$所计算（$c$是一个不依赖于输入规模的常数，在这可理解为分支的最大数量）。


# 4、P问题、NP问题、NP难题、NP完全问题

**定义：** 如果对于问题$p'$存在多项式时间算法，问题$p$就存在多项式时间算法，那么就称问题$p$被多项式归约到问题$p'$，记作$p \propto p'$。

在复杂度理论中，优化问题和判定问题有个明显的区别：判定问题需要输出一个是或否的答案，而优化问题需要输出一个满足约束条件且使目标最优的决策值。然而对于所有优化问题，都有一个相关联的判定问题。例如，在调度问题$F_m \|\| C_{max}$中，目标是要最小化制造期，而与其相关联的判定问题为：是否存在一个调度，使得制造期小于某个给定的值$z$。事实上，优化问题和其相关联的判定问题是紧密联系在一起的：如果对于优化问题存在多项式时间算法，那么对于与其关联的判定问题就存在一个多项式时间算法，反之亦然。也就是说，优化问题和判定问题相互归约，它们是难度等价的。

我们接下来重点关注判定问题，它可以表示为可判定的语言。


**定义：$DTIME$类。** 设$T:\mathbb{N} \rightarrow \mathbb{N}$和$L\subseteq \\{0,1\\}^*$，如果存在运行时间为$O(T(n))$的确定型判定器可判定$L$，则$L \in DTIME(T(n))$。

基于上面的定义，P问题可以表示为$\bigcup_{c\in \mathbb{N}}DTIME(n^c)$，即在多项式时间内可以求解的判定问题。


**定义：$NTIME$类。** 设$T:\mathbb{N} \rightarrow \mathbb{N}$和$L\subseteq \\{0,1\\}^*$，如果存在运行时间为$O(T(n))$的非确定型判定器可判定$L$，则$L \in NTIME(T(n))$。

基于上面的定义，NP问题可以表示为$\bigcup_{c\in \mathbb{N}}NTIME(n^c)$。

NP问题还可以表示为可以在多项式时间内验证的判定问题：

语言$$ L\subseteq \{0,1\}^* $$是一个NP问题，如果存在多项式$p:\mathbb{N} \rightarrow \mathbb{N}$和一个确定型的图灵机$M$，使得对于任意$x \in L$，均有一个$u \in\\{0,1\\}^{p(\|x\|)}$，使得$M$在多项式时间内可以计算$(x,u)$。

在上面的定义中，$M$称为语言$L$的一个验证器，即语言$L$是可确定型验证的，称$u$是$x$关于语言$L$和验证器$M$的一个证据。可以理解为，对于一个NP问题，总是存在一种多项式规模（相对于输入规模）的猜想（即证据$u$），基于该猜想可以在多项式时间内求解该问题（即验证）。

**定义：** 如果对任意判定问题$p' \in NP$均有$p' \propto p$，则称$p$是NP难题；如果$p$是NP难题且$p \in NP$，则称$p$是NP完全的。

显然，P问题和NP完全问题均属于NP问题，P问题是NP问题中最简单的，NP完全问题是NP问题中最难的。关于NP问题是否等于P问题，目前仍然是一个未解难题。如果能证明NP=P，那么P问题=NP问题=NP完全问题。


# 5、空间复杂度

空间复杂度（space complexity）是指算法编写成程序后，在计算机中运行时所需存储空间的度量。记作$$S(n) = O(f(n))$$，其中$n$为问题的规模或大小。

存储空间主要包括三个方面：

(1) 输入或输出数据所占用的存储空间；

(2) 程序指令所占用的存储空间；

(3) 辅助型存储空间。

其中，输入或输出数据所占用的存储空间取决于要解决的问题（一般对输入、输出形式有特定要求），程序指令做占用的存储空间取决于算法代码本身的长短，只有辅助型存储空间是算法运行过程中需要临时占用的，因此与空间复杂度直接相关。一般地，算法的空间复杂度指的都是辅助型存储空间，具体包括函数形参列表分配的存储空间大小，以及在函数体中定义的局部变量的存储空间。如果形参为数组或引用类型，只需为它分配实参传送来的存储地址所占用的空间。对于递归类算法，空间复杂度等于调用一次函数所用的临时存储空间乘以调用该函数次数的积。
